[gd_scene load_steps=4 format=3 uid="uid://qpah81fwwhyf"]

[ext_resource type="Script" uid="uid://buyon2wbhx5ac" path="res://test_parser.gd" id="1_ig7tw"]

[sub_resource type="SystemFont" id="SystemFont_ig7tw"]
font_names = PackedStringArray("Monospace")

[sub_resource type="LabelSettings" id="LabelSettings_0xm2m"]
font = SubResource("SystemFont_ig7tw")

[node name="Main" type="Control" node_paths=PackedStringArray("code_editor", "label", "label2")]
layout_mode = 3
anchors_preset = 0
script = ExtResource("1_ig7tw")
code_editor = NodePath("CodeEdit")
label = NodePath("Label")
label2 = NodePath("Label2")

[node name="CodeEdit" type="CodeEdit" parent="."]
layout_mode = 0
offset_left = 9.0
offset_top = 17.0
offset_right = 332.0
offset_bottom = 630.0
text = "!I have \\d$random()$. I'm rich\\x
{
	!Meow
}

Option {

}
"
placeholder_text = "!Haiiiiii World\\x"
minimap_draw = true
minimap_width = 20
highlight_current_line = true
draw_tabs = true
gutters_draw_line_numbers = true
gutters_draw_fold_gutter = true
indent_size = 6
indent_automatic = true
auto_brace_completion_enabled = true
auto_brace_completion_highlight_matching = true
auto_brace_completion_pairs = {
"\"": "\"",
"$": "$",
"'": "'",
"(": ")",
"[": "]",
"{": "}"
}

[node name="Button" type="Button" parent="."]
layout_mode = 0
offset_left = 78.0
offset_top = 582.0
offset_right = 234.0
offset_bottom = 615.0
text = "Parse!"

[node name="Label" type="Label" parent="."]
layout_mode = 0
offset_left = 354.0
offset_top = 22.0
offset_right = 734.0
offset_bottom = 427.0
label_settings = SubResource("LabelSettings_0xm2m")

[node name="Label2" type="Label" parent="."]
layout_mode = 0
offset_left = 747.0
offset_top = 26.0
offset_right = 1127.0
offset_bottom = 427.0

[node name="ScrollContainer" type="ScrollContainer" parent="."]
layout_mode = 0
offset_left = 337.32
offset_top = 406.0
offset_right = 1152.0
offset_bottom = 643.0
horizontal_scroll_mode = 0

[node name="Label4" type="Label" parent="ScrollContainer"]
custom_minimum_size = Vector2(50, 50)
layout_mode = 2
size_flags_horizontal = 3
text = "========Architecture==========
PARSER: takes code and makes AST
ASSEMBALLER: takes AST and programs and metadata
GLOBAL: takes programs and metadata and makes AGENTs
AGENT: selects between tasks and starts and stops RUNTIMEs
RUNTIME: runs programs

CODE: a string
PROGRAM: an array of INSTRUCTIONs
INSTRUCTION: a bunch of different classes to do something (such as run say something and wait, run gdscript, jump to a line if an condition is met)
AST: a bunch of different classes that hold the informaiton in the CODE in an easily accessable manner

 s
Runtime:
- program: Array[Instructinos]
- current_instruction: int
- async_signal: Signal
- execute(): program[current_instruction].execute(self)
- async_recieve(): execute()
- quit(): async_signal.disconnect(async_recieve)



==========TODO==========
- Design and Implement Task Modifiers & tags
	- More ergonomic/preformant ways of modifying the utiltiy value than a signle funciton
- Multi-tasking
	- A single Agent doing mutliple tasks at a given moment
- Translations/Audio
- Macros
- Cached GDscript Results
- Implement Runtime
	- first convert from AST's nodes to runtime instructions
	- do more error  checking in that process
- Syntax Highlighter??????
- Automated Tests?
- DO NOT REDESIGN THE ENTIRE LANGUAGE AGAIN!!!!!!



======= Documentation ==========
General infoz:
A dialogue system - designed for utility AI agents
allowing any thing to be interupted at any moment and handle that gracefully
Does not use ;
When you get an error message, the first is definitly accurate - after than there is a good chance its meaningless



====Scope====
Anything inside a block { } is scoped the same (even if in oposite order)
Something defined inside a block is not accessable from something outside the block
Shadowing is illegal



====Comments=====
// single line comment
/* block comment */
{
	// block scope
} 


====Run code====
// no return value wanted here
$foo()
$bar()$ $qux()$
$#cheese$ // will only be called the first time

// do have blocking code in the gdscript!!!


====Await====
Await $signal_name$
Will await for the signal
But will also continue to process utilities of other task
So if needs to be interupted with a higher priority task, will do that and stop worring about the signal



====Say====
!Say this stuff
!Use GDscript to say a random number: $random()$
!Use \\d for dollar signs and \\x for explanation points
!This is!  !Two different says!





====Control Flow====
If $condition$ {
	!Condition is true
} else {
	!Condition is false
}
If $condition2$ !Condition2 is true! else !Condition2 is false!

// Note all key words use TitleCase

!This will loop
Loop {
	!forever
	!and
}

While $condition3$ {}
Until $condition4$ {}

Loop {
	// foo will be called each iteration
	$foo()
	// bar will only be called once
	// if the value from bar is used by something, it will be cached and reused each following time for the rest of eternity
	$#bar()
}

Once {
	!This will happen the first time
} Else {
	!This will happen every other time
}


====Tasks====
// Tasks are like functions, but the happen and interupt each other as the utility AI does its magics

Task generic_task_name 15 {
	!15 is the \"utility\" of the task
	!Higher utility means it will go before a task of a lower utility
	// GDscript can be used instead of fixed number
	//Task generic_task_name $15 + sin(time * 6.283) * 2$ {
	
	!At this point if the task got interupted when it comes back, it will go back to the begining
	TaskCheckpoint {}
	!Now the task will return to this point
	
   // If saying AAA then interacted (will say BBB) then switch task, then switch back (require interaction till get back to AA then BBB)
	// Interact again will say DDD
	//if lose interset in task then return
	// instead of going directly to DDD, will first say CCC
	!AAA
	!BBB
	TaskCheckpoint !CCC
	!DDD

	TaskCheckpoint {
		!This works to
		!obvs
	}

	if $should_end_early$
		TaskEnd // Like return

	!When a task is ended, it will immediatly switch to anouther task, and never consider this task again

	!The end of the Task has an implicit TaskEnd
}

// all that code does not do anything until the task is added

TaskAdd generic_task_name
// If that task has a priority higher than the current task, it will immediatly switch to it


====Tags====
// Tags provide extra infoz to the instruction in scope after it
// They can be used to mark which character says a specific line, the facial expression for a given line
// They can also be used to temporarily override the priority of a some lines
// the tag_name

Tag tag_name Value
// foo will be called each time the tagged thing needs to access it
Tag tag_name2 $foo()$
// bar will be called once, then the value will be reused each time
Tag tag_name3 $#bar()$ 
!foo and bar will be called when this line here executes
!only foo is called, value from bar is reused

{
	Tag tag_name4 $this_will_never_be_called()$
}


Tag Expression Happy
!Happy
{
	!Happy
	Tag Expression Sad
	!Sad
}
!Happy
if $condition$
	Tag expression Angry
!Still happy (Tag still happened in scope)

How tags are applied is evaluated before runtime - you cant do any fancy, apply tag A or B depending on a situation - if you need that use a tag that has a GDscript evaluation



====Utility Tag====
// it takes no other task with importance >500 to switch to this task
Task task_name 500 {
	Tag utility 509
	!Stay in this task unless a task of over 509 comes up
	{
		Tag utility 704
		!This is of greater utility to say in one go
		TaskCheckpoint {} // Put the checkpoint instead of of the thing
	}
	!The utility is now 509 again, if there was a task of 601 or whatever, it would eject after this message
	TaskEnd
}"
autowrap_mode = 3
tab_stops = PackedFloat32Array(32)

[connection signal="pressed" from="Button" to="." method="_on_button_pressed"]
